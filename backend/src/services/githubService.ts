import { Octokit } from 'octokit';
import { Issue, PrResult } from '../utils/types';
import { logger } from '../utils/logger';

// Lazily create Octokit so it reads GITHUB_TOKEN after dotenv.config() runs
function getOctokit() {
  return new Octokit({ auth: process.env.GITHUB_TOKEN });
}

interface FileChange { path: string; content: string }

function parseOwnerRepo(repoUrl: string): { owner: string; repo: string } {
  try {
    const match = repoUrl.match(/github\.com[/:]([^/]+)\/([^/.\s]+)/);
    if (match) return { owner: match[1], repo: match[2].replace(/\.git$/, '') };
  } catch { /* fall through */ }
  return { owner: process.env.GITHUB_OWNER || '', repo: process.env.GITHUB_REPO || '' };
}

function buildBranchName(issueId: string, title: string): string {
  const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '').slice(0, 40);
  return `site-surgeon/fix-${slug}-${issueId.slice(0, 8)}`;
}

async function getDefaultBranchSha(octokit: Octokit, owner: string, repo: string): Promise<string> {
  const branch = process.env.GITHUB_DEFAULT_BRANCH || 'main';
  logger.info('Getting default branch SHA', { owner, repo, branch });
  const { data } = await octokit.rest.repos.getBranch({ owner, repo, branch });
  return data.commit.sha;
}

async function createBranch(octokit: Octokit, owner: string, repo: string, branchName: string, baseSha: string): Promise<void> {
  logger.info('Creating branch', { branchName });
  await octokit.rest.git.createRef({ owner, repo, ref: `refs/heads/${branchName}`, sha: baseSha });
}

async function commitFiles(
  octokit: Octokit, owner: string, repo: string, branchName: string,
  parentSha: string, files: FileChange[], commitMessage: string
): Promise<void> {
  logger.info('Committing files', { count: files.length, branchName });

  const blobs = await Promise.all(
    files.map((f) => octokit.rest.git.createBlob({
      owner, repo,
      content: Buffer.from(f.content).toString('base64'),
      encoding: 'base64',
    }))
  );

  const { data: baseCommit } = await octokit.rest.git.getCommit({ owner, repo, commit_sha: parentSha });

  const { data: newTree } = await octokit.rest.git.createTree({
    owner, repo, base_tree: baseCommit.tree.sha,
    tree: files.map((f, i) => ({
      path: f.path, mode: '100644' as const, type: 'blob' as const, sha: blobs[i].data.sha,
    })),
  });

  const { data: newCommit } = await octokit.rest.git.createCommit({
    owner, repo, message: commitMessage, tree: newTree.sha, parents: [parentSha],
  });

  await octokit.rest.git.updateRef({ owner, repo, ref: `heads/${branchName}`, sha: newCommit.sha, force: false });
  logger.info('Files committed', { commitSha: newCommit.sha });
}

async function openPullRequest(
  octokit: Octokit, owner: string, repo: string, branchName: string, issue: Issue, patchSummary: string
): Promise<{ prUrl: string; prNumber: number }> {
  const base = process.env.GITHUB_DEFAULT_BRANCH || 'main';
  logger.info('Creating pull request', { branchName, base });

  const body = [
    '## ðŸ¤– Site Surgeon â€“ Automated Fix',
    '',
    `**Issue:** ${issue.title}`,
    `**Severity:** ${issue.severity}`,
    '',
    '### Description',
    issue.description,
    '',
    '### Changes Made',
    patchSummary || 'See diff for details.',
    '',
    '---',
    '*Auto-generated by Site Surgeon.*',
  ].join('\n');

  const { data } = await octokit.rest.pulls.create({
    owner, repo,
    title: `[Site Surgeon] Fix: ${issue.title}`,
    head: branchName, base, body,
  });

  logger.info('Pull request opened', { prNumber: data.number, prUrl: data.html_url });
  return { prUrl: data.html_url, prNumber: data.number };
}

export async function createAndSubmitFix(
  issue: Issue,
  filesChanged: FileChange[],
  commitMessage: string,
  patchSummary: string,
  autoMerge: boolean
): Promise<PrResult> {
  const octokit = getOctokit();
  const { owner, repo } = parseOwnerRepo(issue.repoUrl);

  if (!owner || !repo) {
    throw new Error('Cannot determine GitHub owner/repo.');
  }

  const branchName = buildBranchName(issue.id, issue.title);

  logger.info('GitHub pipeline starting', { owner, repo, branchName });

  const baseSha = await getDefaultBranchSha(octokit, owner, repo);
  await createBranch(octokit, owner, repo, branchName, baseSha);
  await commitFiles(octokit, owner, repo, branchName, baseSha, filesChanged, commitMessage);
  const { prUrl, prNumber } = await openPullRequest(octokit, owner, repo, branchName, issue, patchSummary);

  let merged = false;
  if (autoMerge) {
    try {
      await octokit.rest.pulls.merge({
        owner, repo, pull_number: prNumber, merge_method: 'squash',
        commit_title: commitMessage,
      });
      merged = true;
      logger.info('Pull request merged', { prNumber });
    } catch (err) {
      logger.warn('Auto-merge failed (branch protection / status checks may be required)', {
        error: err instanceof Error ? err.message : String(err),
      });
    }
  }

  return { prUrl, prNumber, branchName, merged };
}
